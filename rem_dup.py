#!/usr/bin/python
#
#
# 

import sys
# AM i The smallest template-independent mapping quality in the template
# AS i Alignment score generated by aligner
# HI i Query hit index
# IH i Query hit total count
# LB Z Library
# MC Z CIGAR string for mate/next segment
# MD Z String for mismatching positions
# MF ? Reserved for backwards compatibility reasons
# MI Z Molecular identifier; a string that uniquely identifies the molecule from which the record was derived
# MQ i Mapping quality of the mate/next segment
# NH i Number of reported alignments that contain the query in the current record
# NM i Edit distance to the reference

def is_similar(barc1, barc_list,mismatches):
    for barc in barc_list:
        if len(barc) != len(barc1):
            return False
        mmatch = 0 
        for i in range(len(barc)):
            if barc[i] != barc1[i]:
                mmatch = mmatch + 1
    if mmatch > mismatches:
        return False
    else:
        return True
                
                
def len_from_cigar(CIGAR):
    last_num = False
    last_letter = False

    number = ""
    letter = ""
    
    nums = []
    lets = []
    for c in CIGAR:
        if c in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]:
            number = number + c
            if last_letter:
                # last was a letter
                None
            last_num = True
            last_letter = False
        else:
            letter = letter + c
            if last_num:
                # last was a letter
                nums.append(int(number))
                lets.append(letter)
                number = ""
                letter = ""
                
            last_num = False
            last_letter = True
    if last_num:
        # last was a letter
        nums.append(int(number))
        lets.append(letter)
        number = ""
        letter = ""
  #  print nums
  #  print lets
    #                                                                    Q   R
    # M 0 alignment match (can be a sequence match or mismatch)         yes yes
    # I 1 insertion to the referenceyesnoD2deletion from the reference   no yes
    # N 3 skipped region from the reference                              no yes
    # S 4 soft clipping (clipped sequences present inSEQ)               yes no
    # H 5 hard clipping (clipped sequences NOT present inSEQ)            no no
    # P 6 padding (silent deletion from padded reference)                no no
    # = 7 sequence match                                                yes yes
    # X 8 sequence mismatch                                             yes yes
    ll = 0
    i = 0
    for let in lets:
        if let == "M" or let == "I" or let == "N" or let == "=" or let == "X":
            ll = ll + nums[i]
    i = i + 1
    return ll

def proc_bin_str(bitdec):
    #print bitdec
    bitstr = bin(int(bitdec))
    return str(bitstr)[2:]

def read_bam(rem_dup,rem_dup_nobar):
    m = 0
    pe = 0
    mm = 0
    m1 = 0
    m2 = 0
    u = 0
    bc = 0
    nbc = 0
    #fm = 0
    #sm = 0
    um = 0
    num = 0
    unique_reads = {}
    if rem_dup != "":
        barcode_file = open(rem_dup)
    for l in sys.stdin:
        #print l
        ll = l.split()
        ID = ll[0]
        #print ll
        bindec = ll[1]
        mapq = int(ll[4])
        binstr = proc_bin_str(int(bindec))[::-1]
        #print ll[0]
        #print l
        #print binstr[1], ll[6], mapq
        if len(binstr) > 0:
            if binstr[0] == "1":
                pe = pe + 1
        
        if bindec == "0" or bindec == "16":
            m = m + 1
            if mapq == 255:
                u = u + 1
                if rem_dup != "" or rem_dup_nobar:
                    if bindec == "0":
                        strand = "+"
                    else:
                        strand = "-"
                    this_chr = ll[2]
                    start = ll[3]
                    end = str(int(start) + len_from_cigar(ll[5]))
                    if rem_dup != "":
                        barcode_line = barcode_file.readline()
                        b_ID = (barcode_line.split()[0])[1:]
                    
                    if  rem_dup != "" and len(barcode_line.split()) > 1:
                        barcode = barcode_line.split()[1]
                        #print ID, b_ID
                    if rem_dup != "":
                        while not ID == b_ID:
                            #                        print ID, barcode
                            barcode_line = barcode_file.readline()
                            b_ID = (barcode_line.split()[0])[1:]
                            if len(barcode_line.split()) > 1:
                                barcode = barcode_line.split()[1]
                    alignment_ID = "_".join([this_chr, start, end, strand])
                    if not unique_reads.has_key(alignment_ID):
                        if rem_dup != "":
                            unique_reads[alignment_ID] = [barcode]
                        elif rem_dup_nobar:
                            unique_reads[alignment_ID] = ""
                            
                        # print read
                        print l,
                        nbc = nbc + 1
                    else:
                        if rem_dup != "" and not is_similar(barcode, unique_reads[alignment_ID],1):
                            unique_reads[alignment_ID].append(barcode)
                            # print read
                            bc = bc + 1
                            print l,
    #            print l
        if len(binstr) > 2:
            if binstr[2] == "1":
                # unmapped
                um = um + 1
         #       print "Unmapped"
        if len(binstr) > 3:
            if binstr[3] == "1":
                # next unmapped
                num = num + 1
                None
                #print l
                #print "Next unmapped"
        if len(binstr) > 4:
            if binstr[4] == "1":
                None
         #       print "reverse complemented"
        if len(binstr) > 5:
            if binstr[5] == "1":
                None
         #       print "next reverse complemented"
        if len(binstr) > 6:
            if binstr[6] == "1":
                None
         #       print "first segment"
        if len(binstr) > 7:
            if binstr[7] == "1":
                None
          #      print "last segment"
        if len(binstr) > 8:
            if binstr[8] == "1":
                None
          #      print "secondary"
        if len(binstr) > 9:
            if binstr[9] == "1":
                None
                #print l
          #       print "QC fail"
              
        if len(binstr) > 10:
            if binstr[10] == "1":
                #print "duplicate"
                None
        if len(binstr) > 11:
            if binstr[11] == "1":
                #print "supplementary"
                None
        #    print m, pe, u, um, num
    if rem_dup != "":
        print >> sys.stderr, "Uniquely mapped reads:", u, "collapsed(no barcodes)",nbc ,"collapsed(barcodes)",bc + nbc
    elif rem_dup_nobar:
        print >> sys.stderr, "Uniquely mapped reads:", u, "collapsed(no barcodes)",nbc
    else:
        print >> sys.stderr, "Uniquely mapped reads:", u

            #if rem_dup != "":
        #for read, barcodes in unique_reads.items():
           # print read.split("_"), len(barcodes)
            
# 1 0x1 template having multiple segments in sequencing
# 2 0x2 each segment properly aligned according to the aligner
# 4 0x4 segment unmapped
# 8 0x8 next segment in the template unmapped
# 16 0x10 SEQ being reverse complemented
# 32 0x20 SEQ of the next segment in the template being reverse complemented
# 64 0x40 the first segment in the template
# 128 0x80 the last segment in the template
# 256 0x100 secondary alignment
# 512 0x200 not passing filters, such as platform/vendor quality controls
# 1024 0x400 PCR or optical duplicate
# 2048 0x800 supplementary alignment

if __name__ == "__main__":
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-f", action="store", type="string", dest="bbin",default="", help="Input file")
    parser.add_option("-d", action="store", type="string", dest="rem_dup_bar",default="", help="remove duplicted reads using barcodes")
    parser.add_option("-c", action="store_true", dest="rem_dup",default=False, help="Removed duplicated reads without barcodes")
    
    #  parser.add_option("-3", action="store", type="int", dest="trim_three",default=0, help="number of bases to trim if adapter has been removed")
    # parser.add_option("-5", action="store", type="int", dest="trim_five",default=0, help="number of bases to trim if adapter has been removed")

    (options, args) = parser.parse_args()

    read_bam(options.rem_dup_bar,options.rem_dup)
